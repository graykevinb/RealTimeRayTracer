<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Adaptive Path Tracer</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: monospace; color: #fff; user-select: none; -webkit-user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; background: rgba(0, 0, 0, 0.8); padding: 12px; border-radius: 4px; pointer-events: none; }
        #error { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff4444; background: rgba(0,0,0,0.95); padding: 20px; border: 1px solid #f00; display: none; pointer-events: none; }
        .stat { color: #0f0; }
        #controls-left { position: absolute; bottom: 20px; left: 20px; display: flex; flex-direction: column; align-items: center; gap: 5px; pointer-events: none; }
        #controls-right { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .row { display: flex; gap: 5px; }
        .btn { width: 60px; height: 60px; background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255, 255, 255, 0.3); color: #eee; border-radius: 12px; display: flex; justify-content: center; align-items: center; font-size: 24px; font-weight: bold; pointer-events: auto; touch-action: none; backdrop-filter: blur(4px); transition: transform 0.1s; }
        .btn:active { background: rgba(255, 255, 255, 0.4); transform: scale(0.95); }
    </style>
</head>
<body>
    <div id="ui">
        <div>FPS: <span id="fps" class="stat">0</span> | Samples: <span id="samples" class="stat">0</span></div>
        <div>WASD to Move | Drag to Rotate</div>
    </div>
    <div id="error"></div>
    <div id="controls-left">
        <div class="row"><div class="btn" data-key="w">▲</div></div>
        <div class="row">
            <div class="btn" data-key="a">◀</div>
            <div class="btn" data-key="s">▼</div>
            <div class="btn" data-key="d">▶</div>
        </div>
    </div>
    <div id="controls-right">
        <div class="btn" data-key="e">▲</div>
        <div class="btn" data-key="q">▼</div>
    </div>
    <canvas id="canvas"></canvas>
    <script type="module">
        function logError(msg) {
            const el = document.getElementById('error');
            el.style.display = 'block';
            el.innerText = "GPU Error: " + msg;
            console.error(msg);
        }

        // --- Math ---
        const Mat4 = {
            create: () => new Float32Array(16),
            identity: (out) => { out.fill(0); out[0]=out[5]=out[10]=out[15]=1; return out; },
            perspective: (out, fovy, aspect, near, far) => {
                const f = 1.0 / Math.tan(fovy / 2);
                out.fill(0); out[0] = f / aspect; out[5] = f; out[10] = far / (near - far); out[11] = -1; out[14] = (far * near) / (near - far);
                return out;
            },
            lookAt: (out, eye, center, up) => {
                let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                let eyex = eye[0], eyey = eye[1], eyez = eye[2];
                let upx = up[0], upy = up[1], upz = up[2];
                let centerx = center[0], centery = center[1], centerz = center[2];
                z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
                len = 1 / Math.hypot(z0, z1, z2);
                if(len) { len = 1/len; z0*=len; z1*=len; z2*=len; }
                x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
                len = Math.hypot(x0, x1, x2);
                if(!len) { x0=0; x1=0; x2=0; } else { len = 1/len; x0*=len; x1*=len; x2*=len; }
                y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
                len = Math.hypot(y0, y1, y2);
                if(!len) { y0=0; y1=0; y2=0; } else { len = 1/len; y0*=len; y1*=len; y2*=len; }
                out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0; out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
                out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0; out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez); out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez); out[15] = 1;
                return out;
            },
            multiply: (out, a, b) => {
                let a00=a[0], a01=a[1], a02=a[2], a03=a[3]; let a10=a[4], a11=a[5], a12=a[6], a13=a[7];
                let a20=a[8], a21=a[9], a22=a[10], a23=a[11]; let a30=a[12], a31=a[13], a32=a[14], a33=a[15];
                let b0=b[0], b1=b[1], b2=b[2], b3=b[3];
                out[0]=b0*a00+b1*a10+b2*a20+b3*a30; out[1]=b0*a01+b1*a11+b2*a21+b3*a31;
                out[2]=b0*a02+b1*a12+b2*a22+b3*a32; out[3]=b0*a03+b1*a13+b2*a23+b3*a33;
                b0=b[4]; b1=b[5]; b2=b[6]; b3=b[7];
                out[4]=b0*a00+b1*a10+b2*a20+b3*a30; out[5]=b0*a01+b1*a11+b2*a21+b3*a31;
                out[6]=b0*a02+b1*a12+b2*a22+b3*a32; out[7]=b0*a03+b1*a13+b2*a23+b3*a33;
                b0=b[8]; b1=b[9]; b2=b[10]; b3=b[11];
                out[8]=b0*a00+b1*a10+b2*a20+b3*a30; out[9]=b0*a01+b1*a11+b2*a21+b3*a31;
                out[10]=b0*a02+b1*a12+b2*a22+b3*a32; out[11]=b0*a03+b1*a13+b2*a23+b3*a33;
                b0=b[12]; b1=b[13]; b2=b[14]; b3=b[15];
                out[12]=b0*a00+b1*a10+b2*a20+b3*a30; out[13]=b0*a01+b1*a11+b2*a21+b3*a31;
                out[14]=b0*a02+b1*a12+b2*a22+b3*a32; out[15]=b0*a03+b1*a13+b2*a23+b3*a33;
                return out;
            }
        };

        const computeShader = `
        struct Uniforms {
            cameraPos: vec4f,
            cameraFwd: vec4f,
            cameraRight: vec4f,
            cameraUp: vec4f,
            resolution: vec2f,
            frame: f32,
            padding: f32,
        };

        struct Ray { origin: vec3f, direction: vec3f };
        struct Hit { t: f32, pos: vec3f, normal: vec3f, color: vec3f, emission: vec3f, hit: bool };

        @group(0) @binding(0) var<uniform> u: Uniforms;
        @group(0) @binding(1) var historyTex: texture_2d<f32>;
        @group(0) @binding(2) var outputTex: texture_storage_2d<rgba16float, write>;

        // PCG Random (Artifact Free)
        fn rand(seed: ptr<function, u32>) -> f32 {
            let old = *seed;
            *seed = old * 747796405u + 2891336453u;
            let word = ((*seed >> ((*seed >> 28u) + 4u)) ^ *seed) * 277803737u;
            return f32((word >> 22u) ^ word) / 4294967296.0;
        }

        fn hitPlane(r: Ray, n: vec3f, d: f32, col: vec3f, emiss: vec3f, tMax: ptr<function, f32>, best: ptr<function, Hit>) {
            let denom = dot(n, r.direction);
            if (abs(denom) > 1e-5) {
                let t = (d - dot(n, r.origin)) / denom;
                if (t > 0.001 && t < *tMax) {
                    *tMax = t; (*best).t = t; (*best).pos = r.origin + r.direction * t;
                    (*best).normal = select(n, -n, denom > 0.0); (*best).color = col; (*best).emission = emiss; (*best).hit = true;
                }
            }
        }

        fn hitBox(r: Ray, c: vec3f, s: vec3f, ry: f32, col: vec3f, tMax: ptr<function, f32>, best: ptr<function, Hit>) {
            let si = sin(ry); let co = cos(ry);
            let ro = vec3f(co*(r.origin.x-c.x) + si*(r.origin.z-c.z), r.origin.y-c.y, -si*(r.origin.x-c.x) + co*(r.origin.z-c.z));
            let rd = vec3f(co*r.direction.x + si*r.direction.z, r.direction.y, -si*r.direction.x + co*r.direction.z);
            let invD = 1.0/rd; let t0 = (-s-ro)*invD; let t1 = (s-ro)*invD;
            let small = min(t0,t1); let big = max(t0,t1);
            let tmin = max(small.x, max(small.y, small.z)); let tmax_box = min(big.x, min(big.y, big.z));
            if(tmin < tmax_box && tmin > 0.001 && tmin < *tMax) {
                *tMax = tmin; (*best).t = tmin; (*best).pos = r.origin + r.direction * tmin;
                (*best).color = col; (*best).emission = vec3f(0.0); (*best).hit = true;
                let p = ro + rd * tmin; let bias = 1.0001;
                var n = vec3f(0.0);
                if(abs(p.x)>=s.x/bias){n=vec3f(sign(p.x),0.0,0.0);} else if(abs(p.y)>=s.y/bias){n=vec3f(0.0,sign(p.y),0.0);} else{n=vec3f(0.0,0.0,sign(p.z));}
                (*best).normal = vec3f(co*n.x - si*n.z, n.y, si*n.x + co*n.z);
            }
        }

        fn scene(r: Ray) -> Hit {
            var best: Hit; best.hit = false; best.t = 1e20; best.emission = vec3f(0.0); var tMax = 1e20;
            let white=vec3f(0.73); let red=vec3f(0.65,0.05,0.05); let green=vec3f(0.12,0.45,0.15);
            hitPlane(r, vec3f(1.0,0.0,0.0), -1.0, green, vec3f(0.0), &tMax, &best);
            hitPlane(r, vec3f(-1.0,0.0,0.0), -1.0, red, vec3f(0.0), &tMax, &best);
            hitPlane(r, vec3f(0.0,1.0,0.0), -1.0, white, vec3f(0.0), &tMax, &best);
            hitPlane(r, vec3f(0.0,-1.0,0.0), -1.0, white, vec3f(0.0), &tMax, &best);
            hitPlane(r, vec3f(0.0,0.0,1.0), -1.0, white, vec3f(0.0), &tMax, &best);
            let tLight = (0.998 - r.origin.y) / r.direction.y;
            if(tLight > 0.001 && tLight < tMax) {
                let p = r.origin + r.direction * tLight;
                if(p.x > -0.25 && p.x < 0.25 && p.z > -0.25 && p.z < 0.25) {
                    best.hit = true; best.t = tLight; best.pos = p; best.normal = vec3f(0.0,-1.0,0.0); best.emission = vec3f(15.0); tMax = tLight;
                }
            }
            hitBox(r, vec3f(-0.27,-0.4,0.3), vec3f(0.28,0.6,0.28), -0.3, white, &tMax, &best);
            hitBox(r, vec3f(0.27,-0.7,-0.2), vec3f(0.28,0.3,0.28), 0.3, white, &tMax, &best);
            return best;
        }

        fn shadow(p: vec3f, l: vec3f) -> bool {
            let d = l-p; let len = length(d); let hit = scene(Ray(p, d/len));
            return !hit.hit || hit.t >= len - 0.01 || length(hit.emission) > 0.0;
        }

        fn luminance(c: vec3f) -> f32 { return dot(c, vec3f(0.2126, 0.7152, 0.0722)); }

        @compute @workgroup_size(8, 8)
        fn main(@builtin(global_invocation_id) id: vec3u) {
            let dims = textureDimensions(outputTex);
            if (id.x >= dims.x || id.y >= dims.y) { return; }

            var seed = (id.y * dims.x + id.x) * 719393u + u32(u.frame) * 56029u;
            let jitter = vec2f(rand(&seed), rand(&seed)) - 0.5;
            let uv = (vec2f(id.xy) + jitter) / u.resolution * 2.0 - 1.0;
            let aspect = u.resolution.x / u.resolution.y;
            let dir = normalize(uv.x * aspect * u.cameraRight.xyz - uv.y * u.cameraUp.xyz + 2.0 * u.cameraFwd.xyz);
            var ray = Ray(u.cameraPos.xyz, dir);

            var throughput = vec3f(1.0); var radiance = vec3f(0.0);
            for(var b=0; b<4; b++) {
                let hit = scene(ray);
                if(!hit.hit) { break; }
                if(length(hit.emission) > 0.0) { if(b==0){ radiance+=throughput*hit.emission; } break; }
                // NEE
                let lx = rand(&seed)*0.5-0.25; let lz = rand(&seed)*0.5-0.25; let lPos = vec3f(lx, 0.998, lz);
                let toL = lPos - hit.pos; let d2 = dot(toL,toL); let dist = sqrt(d2); let L = toL/dist;
                let ndl = max(0.0, dot(hit.normal, L));
                if(ndl > 0.0 && shadow(hit.pos+hit.normal*0.001, lPos)) {
                    let lCos = max(0.0, dot(vec3f(0.0,-1.0,0.0), -L));
                    radiance += throughput * hit.color * vec3f(15.0) * (ndl * 0.25 / d2) * lCos * 0.3183;
                }
                throughput *= hit.color;
                let r1=rand(&seed); let r2=rand(&seed); let phi=6.283*r1; let sq=sqrt(r2);
                let loc = vec3f(cos(phi)*sq, sin(phi)*sq, sqrt(1.0-r2));
                let n = hit.normal;
                let a = select(vec3f(1.0,0.0,0.0), vec3f(0.0,1.0,0.0), abs(n.x)>0.9);
                let t = normalize(cross(n,a)); let bt = cross(n,t);
                ray.direction = t*loc.x + bt*loc.y + n*loc.z;
                ray.origin = hit.pos + n*0.001;
                if(b>2) { let p = max(throughput.x, max(throughput.y, throughput.z)); if(rand(&seed)>p){break;} throughput/=p; }
            }

            // --- Adaptive Accumulation ---
            var finalColor = vec4f(radiance, 1.0);
            
            if (u.frame > 1.0) {
                // Read exactly the same pixel from previous frame (No spatial Reprojection)
                let history = textureLoad(historyTex, id.xy, 0);
                
                // Calculate difference (Luma based)
                let lumNew = luminance(radiance);
                let lumOld = luminance(history.rgb);
                let diff = abs(lumNew - lumOld);
                
                // Adaptive Alpha:
                // If diff is high (movement/change): alpha -> 0.0 (Take new sample)
                // If diff is low (noise): alpha -> 0.95 (Accumulate)
                // Sensitivity 2.0 means a 0.5 diff drops blend to 0.
                let sensitivity = 2.0;
                var alpha = clamp(1.0 - diff * sensitivity, 0.0, 0.95);
                
                // Boost alpha if we have high samples to ensure convergence
                if (history.a > 10.0) { alpha = max(alpha, 0.9); }
                
                // If frame is very low (just started moving), force fast blend
                if (u.frame < 5.0) { alpha = 0.2; }

                finalColor = vec4f(mix(radiance, history.rgb, alpha), history.a + 1.0);
            }
            
            textureStore(outputTex, id.xy, finalColor);
        }
        `;

        const displayShader = `
            @group(0) @binding(0) var inputTex: texture_2d<f32>;
            @group(0) @binding(1) var mySampler: sampler;
            struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };
            @vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {
                var p = array<vec2f,6>(vec2f(-1,-1),vec2f(1,-1),vec2f(-1,1),vec2f(-1,1),vec2f(1,-1),vec2f(1,1));
                var o: VSOut; o.pos = vec4f(p[i],0.0,1.0); o.uv = p[i]*vec2f(0.5,-0.5)+0.5; return o;
            }
            @fragment fn fs(in: VSOut) -> @location(0) vec4f {
                let c = textureSample(inputTex, mySampler, in.uv).rgb;
                let m = c / (c + vec3f(1.0)); // Reinhard
                return vec4f(pow(m, vec3f(0.4545)), 1.0); // Gamma
            }
        `;

        const canvas = document.getElementById('canvas');
        const fpsEl = document.getElementById('fps');
        const sampEl = document.getElementById('samples');

        let device, context, computePipe, renderPipe, uBuff, texA, texB, bindGroupA, bindGroupB;
        let frame = 0, cam = { pos: [0,0,2.7], pitch:0, yaw:Math.PI }, keys = {};
        let drag = false, lastMouse = {x:0, y:0}, lastTime = 0;
        let dragTouchId = null;
        let pingPong = 0;

        async function init() {
            if(!navigator.gpu) return alert("WebGPU not supported");
            const adapter = await navigator.gpu.requestAdapter();
            device = await adapter.requestDevice();
            device.addEventListener('uncapturederror', e => logError(e.error.message));
            context = canvas.getContext('webgpu');
            context.configure({ device, format: 'bgra8unorm' });

            computePipe = device.createComputePipeline({ layout: 'auto', compute: { module: device.createShaderModule({ code: computeShader }), entryPoint: 'main' }});
            renderPipe = device.createRenderPipeline({ layout: 'auto', vertex: { module: device.createShaderModule({ code: displayShader }), entryPoint: 'vs' }, fragment: { module: device.createShaderModule({ code: displayShader }), entryPoint: 'fs', targets: [{ format: 'bgra8unorm' }] }});

            uBuff = device.createBuffer({ size: 80, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
            window.addEventListener('resize', resize);
            setupInput();
            resize();
            requestAnimationFrame(loop);
        }

        function createTex(w, h) {
            return device.createTexture({ size: [w, h], format: 'rgba16float', usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING });
        }

        function resize() {
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = window.innerHeight * window.devicePixelRatio;
            frame = 0; 
            if(texA) texA.destroy(); if(texB) texB.destroy();
            texA = createTex(canvas.width, canvas.height);
            texB = createTex(canvas.width, canvas.height);

            bindGroupA = device.createBindGroup({ layout: computePipe.getBindGroupLayout(0), entries: [{binding:0, resource:{buffer:uBuff}}, {binding:1, resource:texA.createView()}, {binding:2, resource:texB.createView()}]});
            bindGroupB = device.createBindGroup({ layout: computePipe.getBindGroupLayout(0), entries: [{binding:0, resource:{buffer:uBuff}}, {binding:1, resource:texB.createView()}, {binding:2, resource:texA.createView()}]});
        }

        function updateCam() {
            const s = 0.05;
            const fwd = [Math.sin(cam.yaw)*Math.cos(cam.pitch), Math.sin(cam.pitch), Math.cos(cam.yaw)*Math.cos(cam.pitch)];
            const r = [-fwd[2], 0, fwd[0]]; const rl = Math.hypot(r[0],r[2])||1; r[0]/=rl; r[2]/=rl;
            const u = [r[1]*fwd[2]-r[2]*fwd[1], r[2]*fwd[0]-r[0]*fwd[2], r[0]*fwd[1]-r[1]*fwd[0]];
            let moved = false;
            if(keys.w) { cam.pos[0]+=fwd[0]*s; cam.pos[1]+=fwd[1]*s; cam.pos[2]+=fwd[2]*s; moved=true; }
            if(keys.s) { cam.pos[0]-=fwd[0]*s; cam.pos[1]-=fwd[1]*s; cam.pos[2]-=fwd[2]*s; moved=true; }
            if(keys.d) { cam.pos[0]+=r[0]*s; cam.pos[1]+=r[1]*s; cam.pos[2]+=r[2]*s; moved=true; }
            if(keys.a) { cam.pos[0]-=r[0]*s; cam.pos[1]-=r[1]*s; cam.pos[2]-=r[2]*s; moved=true; }
            if(keys.e) { cam.pos[1]+=s; moved=true; } if(keys.q) { cam.pos[1]-=s; moved=true; }
            if(moved) frame = 0;
            return { fwd, r, u };
        }

        function loop(now) {
            const dt = now - lastTime; lastTime = now; fpsEl.innerText = Math.round(1000/dt);
            const vecs = updateCam();
            frame++;
            sampEl.innerText = frame;

            device.queue.writeBuffer(uBuff, 0, new Float32Array([...cam.pos, 0, ...vecs.fwd, 0, ...vecs.r, 0, ...vecs.u, 0, canvas.width, canvas.height, frame, 0]));

            const enc = device.createCommandEncoder();
            const cBind = pingPong === 0 ? bindGroupA : bindGroupB;
            const dTex = pingPong === 0 ? texB : texA;
            
            const cPass = enc.beginComputePass();
            cPass.setPipeline(computePipe);
            cPass.setBindGroup(0, cBind);
            cPass.dispatchWorkgroups(Math.ceil(canvas.width/8), Math.ceil(canvas.height/8));
            cPass.end();

            const rPass = enc.beginRenderPass({ colorAttachments: [{ view: context.getCurrentTexture().createView(), loadOp: 'clear', storeOp: 'store' }] });
            rPass.setPipeline(renderPipe);
            const dispBind = device.createBindGroup({ layout: renderPipe.getBindGroupLayout(0), entries: [{binding:0, resource:dTex.createView()}, {binding:1, resource:device.createSampler()}] });
            rPass.setBindGroup(0, dispBind);
            rPass.draw(6);
            rPass.end();

            device.queue.submit([enc.finish()]);
            pingPong = 1 - pingPong;
            requestAnimationFrame(loop);
        }

        function setupInput() {
            window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            
            // Mouse
            canvas.addEventListener('click', () => canvas.requestPointerLock());
            window.addEventListener('mousemove', e => {
                if(document.pointerLockElement !== canvas) return;
                cam.yaw -= e.movementX*0.005; cam.pitch = Math.max(-1.5, Math.min(1.5, cam.pitch+e.movementY*0.005));
                frame = 0;
            });

            // Touch
            document.querySelectorAll('.btn').forEach(b => {
                b.addEventListener('touchstart', (e) => { e.preventDefault(); keys[b.dataset.key] = true; });
                b.addEventListener('touchend', (e) => { e.preventDefault(); keys[b.dataset.key] = false; });
            });
            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                if(dragTouchId !== null) return;
                const t = e.changedTouches[0];
                dragTouchId = t.identifier;
                lastMouse = {x:t.clientX, y:t.clientY};
            }, {passive: false});
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if(dragTouchId === null) return;
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(t.identifier === dragTouchId) {
                        const dx = t.clientX - lastMouse.x;
                        const dy = t.clientY - lastMouse.y;
                        lastMouse = {x:t.clientX, y:t.clientY};
                        // Inverted touch controls
                        cam.yaw += dx*0.005; cam.pitch = Math.max(-1.5, Math.min(1.5, cam.pitch+dy*0.005));
                        frame = 0;
                        break;
                    }
                }
            }, {passive: false});
            canvas.addEventListener('touchend', e => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === dragTouchId) { dragTouchId = null; }
                }
            });
        }
        init();
    </script>
</body>
</html>