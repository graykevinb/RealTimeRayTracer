<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Adaptive Path Tracer</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: monospace; color: #fff; user-select: none; -webkit-user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; background: rgba(0, 0, 0, 0.8); padding: 12px; border-radius: 4px; pointer-events: none; }
        #error { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff4444; background: rgba(0,0,0,0.95); padding: 20px; border: 1px solid #f00; display: none; pointer-events: none; }
        .stat { color: #0f0; }
        #controls-left { position: absolute; bottom: 20px; left: 20px; display: flex; flex-direction: column; align-items: center; gap: 5px; pointer-events: none; }
        #controls-right { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .row { display: flex; gap: 5px; }
        .btn { width: 60px; height: 60px; background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255, 255, 255, 0.3); color: #eee; border-radius: 12px; display: flex; justify-content: center; align-items: center; font-size: 24px; font-weight: bold; pointer-events: auto; touch-action: none; backdrop-filter: blur(4px); transition: transform 0.1s; }
        .btn:active { background: rgba(255, 255, 255, 0.4); transform: scale(0.95); }
    </style>
</head>
<body>
    <div id="ui">
        <div>FPS: <span id="fps" class="stat">0</span> | Samples: <span id="samples" class="stat">0</span></div>
        <div>WASD to Move | Drag to Rotate</div>
    </div>
    <div id="error"></div>
    <div id="controls-left">
        <div class="row"><div class="btn" data-key="w">▲</div></div>
        <div class="row">
            <div class="btn" data-key="a">◀</div>
            <div class="btn" data-key="s">▼</div>
            <div class="btn" data-key="d">▶</div>
        </div>
    </div>
    <div id="controls-right">
        <div class="btn" data-key="e">▲</div>
        <div class="btn" data-key="q">▼</div>
        <div class="btn" id="upscale-btn" style="font-size: 10px;">Upscaling</div>
        <div class="btn" id="denoise-btn" style="font-size: 10px;">Denoise</div>
        <div class="btn" id="min-samples-btn" style="font-size: 10px;">Min Samples</div>
    </div>
    <canvas id="canvas"></canvas>
    <script type="module">
        function logError(msg) {
            const el = document.getElementById('error');
            el.style.display = 'block';
            el.innerText = "GPU Error: " + msg;
            console.error(msg);
        }

        // --- Math ---
        const Mat4 = {
            create: () => new Float32Array(16),
            identity: (out) => { out.fill(0); out[0]=out[5]=out[10]=out[15]=1; return out; },
            perspective: (out, fovy, aspect, near, far) => {
                const f = 1.0 / Math.tan(fovy / 2);
                out.fill(0); out[0] = f / aspect; out[5] = f; out[10] = far / (near - far); out[11] = -1; out[14] = (far * near) / (near - far);
                return out;
            },
            lookAt: (out, eye, center, up) => {
                let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                let eyex = eye[0], eyey = eye[1], eyez = eye[2];
                let upx = up[0], upy = up[1], upz = up[2];
                let centerx = center[0], centery = center[1], centerz = center[2];
                z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
                len = 1 / Math.hypot(z0, z1, z2);
                if(len) { len = 1/len; z0*=len; z1*=len; z2*=len; }
                x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
                len = Math.hypot(x0, x1, x2);
                if(!len) { x0=0; x1=0; x2=0; } else { len = 1/len; x0*=len; x1*=len; x2*=len; }
                y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
                len = Math.hypot(y0, y1, y2);
                if(!len) { y0=0; y1=0; y2=0; } else { len = 1/len; y0*=len; y1*=len; y2*=len; }
                out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0; out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
                out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0; out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez); out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez); out[15] = 1;
                return out;
            },
            multiply: (out, a, b) => {
                let a00=a[0], a01=a[1], a02=a[2], a03=a[3]; let a10=a[4], a11=a[5], a12=a[6], a13=a[7];
                let a20=a[8], a21=a[9], a22=a[10], a23=a[11]; let a30=a[12], a31=a[13], a32=a[14], a33=a[15];
                let b0=b[0], b1=b[1], b2=b[2], b3=b[3];
                out[0]=b0*a00+b1*a10+b2*a20+b3*a30; out[1]=b0*a01+b1*a11+b2*a21+b3*a31;
                out[2]=b0*a02+b1*a12+b2*a22+b3*a32; out[3]=b0*a03+b1*a13+b2*a23+b3*a33;
                b0=b[4]; b1=b[5]; b2=b[6]; b3=b[7];
                out[4]=b0*a00+b1*a10+b2*a20+b3*a30; out[5]=b0*a01+b1*a11+b2*a21+b3*a31;
                out[6]=b0*a02+b1*a12+b2*a22+b3*a32; out[7]=b0*a03+b1*a13+b2*a23+b3*a33;
                b0=b[8]; b1=b[9]; b2=b[10]; b3=b[11];
                out[8]=b0*a00+b1*a10+b2*a20+b3*a30; out[9]=b0*a01+b1*a11+b2*a21+b3*a31;
                out[10]=b0*a02+b1*a12+b2*a22+b3*a32; out[11]=b0*a03+b1*a13+b2*a23+b3*a33;
                b0=b[12]; b1=b[13]; b2=b[14]; b3=b[15];
                out[12]=b0*a00+b1*a10+b2*a20+b3*a30; out[13]=b0*a01+b1*a11+b2*a21+b3*a31;
                out[14]=b0*a02+b1*a12+b2*a22+b3*a32; out[15]=b0*a03+b1*a13+b2*a23+b3*a33;
                return out;
            }
        };

        const computeShader = `
        struct Uniforms {
            cameraPos: vec4f,
            cameraFwd: vec4f,
            cameraRight: vec4f,
            cameraUp: vec4f,
            prevViewProj: mat4x4<f32>, // Added matrix for reprojection
            resolution: vec2f,
            frame: f32,
            padding: f32,
        };

        struct Reservoir {
            y: vec4f,       // Light sample position (xyz)
            w_sum: f32,     // Sum of weights
            M: u32,         // Count
            W: f32,         // RIS weight
            pad: u32        // Padding to 32 bytes
        };

        struct Ray { origin: vec3f, direction: vec3f };
        struct Hit { t: f32, pos: vec3f, normal: vec3f, color: vec3f, emission: vec3f, mat: u32, hit: bool };

        @group(0) @binding(0) var<uniform> u: Uniforms;
        @group(0) @binding(1) var historyTex: texture_2d<f32>;
        @group(0) @binding(2) var outputTex: texture_storage_2d<rgba16float, write>;
        @group(0) @binding(3) var<storage, read> resInput: array<Reservoir>;
        @group(0) @binding(4) var<storage, read_write> resOutput: array<Reservoir>;
        @group(0) @binding(5) var normDepthInput: texture_2d<f32>;
        @group(0) @binding(6) var normDepthOutput: texture_storage_2d<rgba16float, write>;
        @group(0) @binding(7) var<storage, read_write> resInter: array<Reservoir>;

        // PCG Random (Artifact Free)
        fn rand(seed: ptr<function, u32>) -> f32 {
            let old = *seed;
            *seed = old * 747796405u + 2891336453u;
            let word = ((*seed >> ((*seed >> 28u) + 4u)) ^ *seed) * 277803737u;
            return f32((word >> 22u) ^ word) / 4294967296.0;
        }

        fn hitPlane(r: Ray, n: vec3f, d: f32, col: vec3f, emiss: vec3f, tMax: ptr<function, f32>, best: ptr<function, Hit>) {
            let denom = dot(n, r.direction);
            if (abs(denom) > 1e-5) {
                let t = (d - dot(n, r.origin)) / denom;
                if (t > 0.001 && t < *tMax) {
                    *tMax = t; (*best).t = t; (*best).pos = r.origin + r.direction * t;
                    (*best).normal = select(n, -n, denom > 0.0); (*best).color = col; (*best).emission = emiss;
                    (*best).mat = 0u; (*best).hit = true;
                }
            }
        }

        fn hitBox(r: Ray, c: vec3f, s: vec3f, ry: f32, col: vec3f, tMax: ptr<function, f32>, best: ptr<function, Hit>) {
            let si = sin(ry); let co = cos(ry);
            let ro = vec3f(co*(r.origin.x-c.x) + si*(r.origin.z-c.z), r.origin.y-c.y, -si*(r.origin.x-c.x) + co*(r.origin.z-c.z));
            let rd = vec3f(co*r.direction.x + si*r.direction.z, r.direction.y, -si*r.direction.x + co*r.direction.z);
            let invD = 1.0/rd; let t0 = (-s-ro)*invD; let t1 = (s-ro)*invD;
            let small = min(t0,t1); let big = max(t0,t1);
            let tmin = max(small.x, max(small.y, small.z)); let tmax_box = min(big.x, min(big.y, big.z));
            if(tmin < tmax_box && tmin > 0.001 && tmin < *tMax) {
                *tMax = tmin; (*best).t = tmin; (*best).pos = r.origin + r.direction * tmin;
                (*best).color = col; (*best).emission = vec3f(0.0); (*best).mat = 0u; (*best).hit = true;
                let p = ro + rd * tmin; let bias = 1.0001;
                var n = vec3f(0.0);
                if(abs(p.x)>=s.x/bias){n=vec3f(sign(p.x),0.0,0.0);} else if(abs(p.y)>=s.y/bias){n=vec3f(0.0,sign(p.y),0.0);} else{n=vec3f(0.0,0.0,sign(p.z));}
                (*best).normal = vec3f(co*n.x - si*n.z, n.y, si*n.x + co*n.z);
            }
        }

        fn hitSphere(r: Ray, c: vec3f, radSq: f32, invRad: f32, col: vec3f, mat: u32, tMax: ptr<function, f32>, best: ptr<function, Hit>) {
            let oc = r.origin - c;
            let b = dot(oc, r.direction);
            let det = b*b - (dot(oc,oc) - radSq);
            if(det > 0.0) {
                let sq = sqrt(det);
                var t = -b - sq;
                if(t < 0.001) { t = -b + sq; }
                if(t > 0.001 && t < *tMax) {
                    *tMax = t;
                    (*best).t = t; (*best).pos = r.origin + r.direction * t;
                    (*best).normal = ((*best).pos - c) * invRad;
                    (*best).color = col; (*best).emission = vec3f(0.0);
                    (*best).mat = mat; (*best).hit = true;
                }
            }
        }

        fn scene(r: Ray) -> Hit {
            var best: Hit; best.hit = false; best.t = 1e20; best.emission = vec3f(0.0); best.mat = 0u; var tMax = 1e20;
            let white=vec3f(0.73); let red=vec3f(0.65,0.05,0.05); let green=vec3f(0.12,0.45,0.15);
            hitPlane(r, vec3f(1.0,0.0,0.0), -1.0, green, vec3f(0.0), &tMax, &best);
            hitPlane(r, vec3f(-1.0,0.0,0.0), -1.0, red, vec3f(0.0), &tMax, &best);
            hitPlane(r, vec3f(0.0,1.0,0.0), -1.0, white, vec3f(0.0), &tMax, &best);
            hitPlane(r, vec3f(0.0,-1.0,0.0), -1.0, white, vec3f(0.0), &tMax, &best);
            hitPlane(r, vec3f(0.0,0.0,1.0), -1.0, white, vec3f(0.0), &tMax, &best);
            let tLight = (0.998 - r.origin.y) / r.direction.y;
                if(tLight > 0.001 && tLight < tMax) {
                    let p = r.origin + r.direction * tLight;
                    if(p.x > -0.25 && p.x < 0.25 && p.z > -0.25 && p.z < 0.25) {
                        best.hit = true; best.t = tLight; best.pos = p; best.normal = vec3f(0.0,-1.0,0.0); 
                        best.emission = vec3f(15.0); best.mat = 0u; tMax = tLight;
                    }
                }
            hitSphere(r, vec3f(0.0, -0.7, 0.15), 0.09, 3.3333, vec3f(0.98), 1u, &tMax, &best);
            hitBox(r, vec3f(-0.27,-0.4,0.3), vec3f(0.28,0.6,0.28), -0.3, white, &tMax, &best);
            hitBox(r, vec3f(0.27,-0.7,-0.2), vec3f(0.28,0.3,0.28), 0.3, white, &tMax, &best);
            return best;
        }

        fn shadow(p: vec3f, l: vec3f) -> bool {
            let d = l-p; let len = length(d); let hit = scene(Ray(p, d/len));
            return !hit.hit || hit.t >= len - 0.01 || (hit.mat == 1u) || length(hit.emission) > 0.0;
        }

        fn luminance(c: vec3f) -> f32 { return dot(c, vec3f(0.2126, 0.7152, 0.0722)); }

        fn emptyReservoir() -> Reservoir {
            return Reservoir(vec4f(0.0), 0.0, 0u, 0.0, 0u);
        }

        fn updateReservoir(r: ptr<function, Reservoir>, y: vec4f, w: f32, c: u32, seed: ptr<function, u32>) {
            (*r).w_sum += w;
            (*r).M += c;
            if (rand(seed) < (w / (*r).w_sum)) {
                (*r).y = y;
            }
        }

        fn evalPHat(pos: vec3f, normal: vec3f, color: vec3f, lightPos: vec3f) -> f32 {
             let toL = lightPos - pos;
             let d2 = max(0.02, dot(toL, toL)); // Clamp min distance to avoid singularity
             let dist = sqrt(d2);
             let L = toL / dist;
             let ndl = max(0.0, dot(normal, L));
             let lCos = max(0.0, dot(vec3f(0.0,-1.0,0.0), -L));
             if (ndl > 0.0 && lCos > 0.0) {
                 return luminance(color) * 4.7745 * (ndl * lCos / d2);
             }
             return 0.0;
        }

        @compute @workgroup_size(16, 16)
        fn mainTemporal(@builtin(global_invocation_id) id: vec3u) {
            let dims = textureDimensions(outputTex);
            if (id.x >= dims.x || id.y >= dims.y) { return; }

            var seed = (id.y * dims.x + id.x) * 719393u + u32(u.frame) * 56029u;
            let jitter = vec2f(rand(&seed), rand(&seed)) - 0.5;
            let uv = (vec2f(id.xy) + jitter) / u.resolution * 2.0 - 1.0;
            let aspect = u.resolution.x / u.resolution.y;
            let dir = normalize(uv.x * aspect * u.cameraRight.xyz - uv.y * u.cameraUp.xyz + 2.0 * u.cameraFwd.xyz);
            var ray = Ray(u.cameraPos.xyz, dir);

            var firstDiffuse = true;
            var R = emptyReservoir();
            var hasHit = false;
            var firstHitNorm = vec3f(0.0);
            var firstHitDepth = 0.0;

            for(var b=0; b<6; b++) {
                let hit = scene(ray);
                if(!hit.hit) { break; }
                
                if (b == 0) {
                    hasHit = true;
                    firstHitNorm = hit.normal;
                    firstHitDepth = distance(hit.pos, u.cameraPos.xyz);
                }

                if(length(hit.emission) > 0.0) { 
                    break; 
                }
                
                if (hit.mat == 1u) { // Glass
                    let n = hit.normal;
                    let d = ray.direction;
                    let dotDN = dot(d, n);
                    let isFront = dotDN < 0.0;
                    let realN = select(-n, n, isFront);
                    let eta = select(1.5, 1.0/1.5, isFront);
                    let cosTheta = min(dot(-d, realN), 1.0);
                    let sinTheta = sqrt(1.0 - cosTheta*cosTheta);
                    let cannotRefract = eta * sinTheta > 1.0;
                    let r0 = (1.0 - 1.5)/(1.0 + 1.5); let r0s = r0*r0;
                    let schlick = r0s + (1.0 - r0s)*pow(1.0 - cosTheta, 5.0);
                    var newDir = vec3f(0.0);
                    if (cannotRefract || schlick > rand(&seed)) { newDir = reflect(d, realN); } else { newDir = refract(d, realN, eta); }
                    ray.origin = hit.pos + newDir * 0.001;
                    ray.direction = newDir;
                } else {
                    if (firstDiffuse) {
                        // 1. Initial Candidates
                        for (var i=0; i<32; i++) {
                            let lx = rand(&seed)*0.5-0.25; let lz = rand(&seed)*0.5-0.25; let lPos = vec3f(lx, 0.998, lz);
                            let p_hat = evalPHat(hit.pos, hit.normal, hit.color, lPos);
                            let w = p_hat * 0.25;
                            updateReservoir(&R, vec4f(lPos, 1.0), w, 1u, &seed);
                        }

                        var p_hat_curr = evalPHat(hit.pos, hit.normal, hit.color, R.y.xyz);
                        R.W = 0.0;
                        if(p_hat_curr > 0.0) { 
                            R.W = R.w_sum / max(1e-5, f32(R.M) * p_hat_curr); 
                        }

                        // 2. Temporal Reuse
                        if (u.frame > 1.0) {
                            let clipPos = u.prevViewProj * vec4f(hit.pos, 1.0);
                            let ndc = clipPos.xyz / clipPos.w;
                            let prevUV = vec2f(ndc.x * 0.5 + 0.5, (1.0 - ndc.y) * 0.5);
                            let prevID = vec2u(prevUV * vec2f(dims));

                            if (prevID.x >= 0u && prevID.x < dims.x && prevID.y >= 0u && prevID.y < dims.y) {
                                let idx = prevID.y * dims.x + prevID.x;
                                var prevR = resInput[idx];
                                let prevND = textureLoad(normDepthInput, prevID, 0);
                                let depth = distance(hit.pos, u.cameraPos.xyz);
                                if (dot(prevND.xyz, hit.normal) > 0.9 && abs(prevND.w - depth) < 0.1 * depth) {
                                    prevR.M = min(prevR.M, 20u * R.M);
                                    let p_hat_prev = evalPHat(hit.pos, hit.normal, hit.color, prevR.y.xyz);
                                    let w_prev = p_hat_prev * prevR.W * f32(prevR.M);
                                    updateReservoir(&R, prevR.y, w_prev, prevR.M, &seed);
                                }
                            }
                        }
                        
                        let final_p_hat = evalPHat(hit.pos, hit.normal, hit.color, R.y.xyz);
                        R.W = 0.0;
                        if (final_p_hat > 0.0) { R.W = R.w_sum / max(1e-5, f32(R.M) * final_p_hat); }
                        
                        firstHitNorm = hit.normal;
                        firstHitDepth = distance(hit.pos, u.cameraPos.xyz);
                        firstDiffuse = false;
                    }
                    break; 
                }
            }

            let outIdx = id.y * dims.x + id.x;
            resInter[outIdx] = R;
            
            if (hasHit) {
                textureStore(normDepthOutput, id.xy, vec4f(firstHitNorm, firstHitDepth));
            } else {
                textureStore(normDepthOutput, id.xy, vec4f(0.0, 0.0, 0.0, 1e20));
            }
        }

        @compute @workgroup_size(16, 16)
        fn mainSpatial(@builtin(global_invocation_id) id: vec3u) {
            let dims = textureDimensions(outputTex);
            if (id.x >= dims.x || id.y >= dims.y) { return; }
            
            var seed = (id.y * dims.x + id.x) * 719393u + u32(u.frame) * 56029u + 12345u;
            
            let jitter = vec2f(rand(&seed), rand(&seed)) - 0.5;
            let uv = (vec2f(id.xy) + jitter) / u.resolution * 2.0 - 1.0;
            let aspect = u.resolution.x / u.resolution.y;
            let dir = normalize(uv.x * aspect * u.cameraRight.xyz - uv.y * u.cameraUp.xyz + 2.0 * u.cameraFwd.xyz);
            var ray = Ray(u.cameraPos.xyz, dir);
            
            var hit = scene(ray);
            var throughput = vec3f(1.0);
            var radiance = vec3f(0.0);
            var specularBounce = true;
            var firstDiffuse = true;
            
            // Simple loop to find first diffuse hit
            for(var b=0; b<6; b++) {
                if(!hit.hit) { break; }
                if(length(hit.emission) > 0.0) { 
                    if(specularBounce){ radiance+=throughput*hit.emission; } 
                    break; 
                }
                if (hit.mat == 1u) {
                    // Glass logic (abbreviated)
                    let n = hit.normal; let d = ray.direction;
                    let dotDN = dot(d, n); let isFront = dotDN < 0.0;
                    let realN = select(-n, n, isFront); let eta = select(1.5, 1.0/1.5, isFront);
                    let cosTheta = min(dot(-d, realN), 1.0);
                    let sinTheta = sqrt(1.0 - cosTheta*cosTheta);
                    let cannotRefract = eta * sinTheta > 1.0;
                    let r0 = (1.0 - 1.5)/(1.0 + 1.5); let r0s = r0*r0;
                    let schlick = r0s + (1.0 - r0s)*pow(1.0 - cosTheta, 5.0);
                    var newDir = vec3f(0.0);
                    if (cannotRefract || schlick > rand(&seed)) { newDir = reflect(d, realN); } else { newDir = refract(d, realN, eta); }
                    ray.origin = hit.pos + newDir * 0.001; ray.direction = newDir;
                    hit = scene(ray);
                    specularBounce = true;
                } else {
                    if (firstDiffuse) {
                        // Diffuse Hit found
                        let idx = id.y * dims.x + id.x;
                        var R = resInter[idx];
                    
                    // 3. Spatial Reuse
                    let currDepth = distance(hit.pos, u.cameraPos.xyz);
                    // Since we are in Pass 2, normDepthOutput contains CURRENT frame G-Buffer (written in Pass 1)
                    // We can use it to validate spatial neighbors from THIS frame
                    
                    for (var k=0; k<3; k++) {
                         let rad = 30.0;
                         let angle = rand(&seed) * 6.283;
                         let r = sqrt(rand(&seed)) * rad;
                         let offset = vec2f(cos(angle), sin(angle)) * r;
                         let nPos = vec2i(vec2f(id.xy) + offset);
                         if (nPos.x >= 0 && nPos.x < i32(dims.x) && nPos.y >= 0 && nPos.y < i32(dims.y)) {
                             let nIdx = u32(nPos.y) * dims.x + u32(nPos.x);
                             var nR = resInter[nIdx]; // Reuse from CURRENT frame candidates
                             
                             // Validate using CURRENT G-Buffer (which is in normDepthOutput but we can read it as texture? No it is storage write-only in pass 1?
                             // Wait, bind group 6 is 'write'. We can't read it in Pass 2 if it's bound as write.
                             // We need to bind it as READ in Pass 2.
                             
                             // Let's assume we bind normDepthOutput to binding 5 (normDepthInput) in Pass 2? 
                             // Or better: Pass 1 writes to A. Pass 2 reads A. Next frame Pass 1 reads A? No.
                             // We need 3 textures? No.
                             
                             // Simpler: Just re-read textureLoad(normDepthOutput...)? No, can't read storage texture in all tiers.
                             // But wait, normDepthOutput is 'texture_storage_2d'.
                             // We can make it 'read_write' or use a separate texture.
                             // Actually, since we are in the same frame, Pass 1 wrote to 'normDepthOutput'.
                             // We can bind that texture as a SAMPLED texture (binding 5) in Pass 2.
                             
                             // So in Pass 2: binding 5 is the texture written in Pass 1.
                             
                             let nND = textureLoad(normDepthInput, nPos, 0);
                             
                             if (dot(nND.xyz, hit.normal) > 0.9 && abs(nND.w - currDepth) < 0.1 * currDepth) {
                                 let p_hat_n = evalPHat(hit.pos, hit.normal, hit.color, nR.y.xyz);
                                 let w_n = p_hat_n * nR.W * f32(nR.M);
                                 updateReservoir(&R, nR.y, w_n, nR.M, &seed);
                             }
                         }
                    }
                    
                    let final_p_hat = evalPHat(hit.pos, hit.normal, hit.color, R.y.xyz);
                    R.W = 0.0;
                    if (final_p_hat > 0.0) { 
                        R.W = R.w_sum / max(1e-5, f32(R.M) * final_p_hat); 
                        R.W = min(R.W, 10.0);
                    }
                    
                    // Store final reservoir for next frame's temporal reuse
                    resOutput[idx] = R;

                    // Shade
                    if (shadow(hit.pos+hit.normal*0.001, R.y.xyz)) {
                        let lPos = R.y.xyz;
                        let toL = lPos - hit.pos; let d2 = max(0.02, dot(toL,toL));
                        let ndl = max(0.0, dot(hit.normal, normalize(toL)));
                        let lCos = max(0.0, dot(vec3f(0.0,-1.0,0.0), -normalize(toL)));
                        let val = hit.color * 4.7745 * (ndl * lCos / d2);
                        radiance += throughput * val * R.W;
                    }
                    
                    // Mark processed
                    firstDiffuse = false;
                } else {
                    // Secondary Bounce NEE (Standard)
                    let lx = rand(&seed)*0.5-0.25; let lz = rand(&seed)*0.5-0.25; let lPos = vec3f(lx, 0.998, lz);
                    let toL = lPos - hit.pos; let d2 = dot(toL,toL); let dist = sqrt(d2); let L = toL/dist;
                    let ndl = max(0.0, dot(hit.normal, L));
                    if(ndl > 0.0 && shadow(hit.pos+hit.normal*0.001, lPos)) {
                        let lCos = max(0.0, dot(vec3f(0.0,-1.0,0.0), -L));
                        radiance += throughput * hit.color * vec3f(15.0) * (ndl * 0.25 / d2) * lCos * 0.3183;
                    }
                }
                
                // Continue Path Tracing (Indirect Bounce)
                throughput *= hit.color;
                let r1=rand(&seed); let r2=rand(&seed); let phi=6.283*r1; let sq=sqrt(r2);
                let loc = vec3f(cos(phi)*sq, sin(phi)*sq, sqrt(1.0-r2));
                let n = hit.normal;
                let a = select(vec3f(1.0,0.0,0.0), vec3f(0.0,1.0,0.0), abs(n.x)>0.9);
                let t = normalize(cross(n,a)); let bt = cross(n,t);
                ray.direction = t*loc.x + bt*loc.y + n*loc.z;
                ray.origin = hit.pos + n*0.001;
                specularBounce = false;
                hit = scene(ray);
            }
        }
            
            var finalColor = vec4f(radiance, 1.0);
            if (u.frame > 1.0) {
                let history = textureLoad(historyTex, id.xy, 0);
                var alpha = 0.0;
                if (u.frame < 5.0) { alpha = 0.2; } else if (u.frame < 20.0) { alpha = 0.8; } else { alpha = 0.96; }
                finalColor = vec4f(mix(radiance, history.rgb, alpha), history.a + 1.0);
            }
            textureStore(outputTex, id.xy, finalColor);
        }
        `;

        const denoiseShader = `
        @group(0) @binding(0) var inputTex: texture_2d<f32>;
        @group(0) @binding(1) var outputTex: texture_storage_2d<rgba16float, write>;
        
        struct Uniforms {
            resolution: vec2f,
            stepWidth: f32,
            padding: f32,
        };
        @group(0) @binding(2) var<uniform> u: Uniforms;

        @compute @workgroup_size(16, 16)
        fn main(@builtin(global_invocation_id) id: vec3u) {
            let dims = textureDimensions(inputTex);
            if (id.x >= dims.x || id.y >= dims.y) { return; }

            // A-Trous Wavelet Kernel (5x5) - Modified for simplicity
            // Standard kernel: 1/16 * [1, 4, 6, 4, 1] for separable 1D.
            // Using a sparse sparse approximation here:
            
            let center = textureLoad(inputTex, id.xy, 0);
            let step = i32(u.stepWidth);
            
            var sum = center;
            var cum_w = 1.0;
            
            // Reduced kernel size to 3x3 to prevent ringing/ghosting at edges
            // and using a stricter edge weight.
            for(var y = -1; y <= 1; y++) {
                for(var x = -1; x <= 1; x++) {
                    if(x==0 && y==0) { continue; }
                    
                    let uv = vec2i(id.xy) + vec2i(x, y) * step;
                    if(uv.x < 0 || uv.y < 0 || uv.x >= i32(dims.x) || uv.y >= i32(dims.y)) { continue; }
                    
                    let c = textureLoad(inputTex, uv, 0);
                    
                    let diff = length(c.rgb - center.rgb);
                    
                    // Very strict edge stopping
                    // Reduced from 256.0 to 64.0 because we are doing fewer passes, so we need slightly more blend power.
                    let w_color = exp(-diff * diff * 64.0); 
                    
                    // Simple box weight
                    let w = w_color;
                    
                    sum += c * w;
                    cum_w += w;
                }
            }
            
            textureStore(outputTex, id.xy, sum / cum_w);
        }
        `;

        const displayShader = `
            struct Uniforms {
                cameraPos: vec4f,
                cameraFwd: vec4f,
                cameraRight: vec4f,
                cameraUp: vec4f,
                resolution: vec2f,
                frame: f32,
                upscalingEnabled: f32,
            };
            @group(0) @binding(0) var inputTex: texture_2d<f32>;
            @group(0) @binding(1) var mySampler: sampler;
            @group(0) @binding(2) var<uniform> u: Uniforms;

            struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f };
            @vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {
                var p = array<vec2f,6>(vec2f(-1,-1),vec2f(1,-1),vec2f(-1,1),vec2f(-1,1),vec2f(1,-1),vec2f(1,1));
                var o: VSOut; o.pos = vec4f(p[i],0.0,1.0); o.uv = p[i]*vec2f(0.5,-0.5)+0.5; return o;
            }

            // Simple RCAS-like sharpening
            fn fsr_rcas(uv: vec2f) -> vec3f {
                let c = textureSample(inputTex, mySampler, uv).rgb;
                // If FSR is enabled, we expect the input to be upscaled by the hardware sampler (Bilinear).
                // We just add a simple sharpen filter here to mimic RCAS.
                
                let texDim = vec2f(textureDimensions(inputTex));
                let one = 1.0 / texDim;
                
                let n = textureSample(inputTex, mySampler, uv + vec2f(0.0, -one.y)).rgb;
                let s = textureSample(inputTex, mySampler, uv + vec2f(0.0, one.y)).rgb;
                let e = textureSample(inputTex, mySampler, uv + vec2f(one.x, 0.0)).rgb;
                let w = textureSample(inputTex, mySampler, uv + vec2f(-one.x, 0.0)).rgb;

                // Simple Unsharp Mask for demo purposes (RCAS is more complex)
                let neighbors = (n + s + e + w) * 0.25;
                let detail = c - neighbors;
                return c + detail * 0.5; // 0.5 sharpness
            }

            @fragment fn fs(in: VSOut) -> @location(0) vec4f {
                var c = vec3f(0.0);
                if (u.upscalingEnabled > 0.5) {
                    c = fsr_rcas(in.uv);
                } else {
                    c = textureSample(inputTex, mySampler, in.uv).rgb;
                }
                let m = c / (c + vec3f(1.0)); // Reinhard
                return vec4f(pow(m, vec3f(0.4545)), 1.0); // Gamma
            }
        `;

        const canvas = document.getElementById('canvas');
        const fpsEl = document.getElementById('fps');
        const sampEl = document.getElementById('samples');

        let device, context, computePipeTemporal, computePipeSpatial, renderPipe, uBuff, texA, texB, bindGroupATem, bindGroupASpa, bindGroupBTem, bindGroupBSpa, sampler;
        let resBufA, resBufB, resBufInter;
        let texNormDepthA, texNormDepthB;
        // Denoise globals
        let denoisePipe, denoiseBuff, denoiseBindGroups = [], texDenoiseA, texDenoiseB;
        let frame = 0, cam = { pos: [0,0,2.7], pitch:0, yaw:Math.PI }, keys = {};
        let drag = false, lastMouse = {x:0, y:0}, lastTime = 0;
        let dragTouchId = null;
        let pingPong = 0;
        let upscalingEnabled = false;
        let denoisingEnabled = false;
        let minSamplesMode = false;
        let renderScale = 1.0;
        
        let viewProj = Mat4.create();
        let prevViewProj = Mat4.create();
        Mat4.identity(prevViewProj);

        async function init() {
            if(!navigator.gpu) return alert("WebGPU not supported");
            const adapter = await navigator.gpu.requestAdapter();
            device = await adapter.requestDevice();
            device.addEventListener('uncapturederror', e => logError(e.error.message));
            context = canvas.getContext('webgpu');
            context.configure({ device, format: 'bgra8unorm' });
            
            sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });

            computePipeTemporal = device.createComputePipeline({ layout: 'auto', compute: { module: device.createShaderModule({ code: computeShader }), entryPoint: 'mainTemporal' }});
            computePipeSpatial = device.createComputePipeline({ layout: 'auto', compute: { module: device.createShaderModule({ code: computeShader }), entryPoint: 'mainSpatial' }});
            
            denoisePipe = device.createComputePipeline({ layout: 'auto', compute: { module: device.createShaderModule({ code: denoiseShader }), entryPoint: 'main' }});
            renderPipe = device.createRenderPipeline({ layout: 'auto', vertex: { module: device.createShaderModule({ code: displayShader }), entryPoint: 'vs' }, fragment: { module: device.createShaderModule({ code: displayShader }), entryPoint: 'fs', targets: [{ format: 'bgra8unorm' }] }});

            uBuff = device.createBuffer({ size: 144, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
            denoiseBuff = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

            window.addEventListener('resize', resize);
            setupInput();
            resize();
            requestAnimationFrame(loop);
        }

        function createTex(w, h) {
            return device.createTexture({ size: [w, h], format: 'rgba16float', usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING });
        }

        function resize() {
            const dispW = window.innerWidth * window.devicePixelRatio;
            const dispH = window.innerHeight * window.devicePixelRatio;
            canvas.width = dispW;
            canvas.height = dispH;
            
            const rndW = Math.floor(dispW * renderScale);
            const rndH = Math.floor(dispH * renderScale);

            frame = 0; 
            if(texA) texA.destroy(); if(texB) texB.destroy();
            if(texDenoiseA) texDenoiseA.destroy(); if(texDenoiseB) texDenoiseB.destroy();
            if(resBufA) resBufA.destroy(); if(resBufB) resBufB.destroy();
            if(texNormDepthA) texNormDepthA.destroy(); if(texNormDepthB) texNormDepthB.destroy();

            texA = createTex(rndW, rndH);
            texB = createTex(rndW, rndH);
            texDenoiseA = createTex(rndW, rndH);
            texDenoiseB = createTex(rndW, rndH);
            texNormDepthA = createTex(rndW, rndH);
            texNormDepthB = createTex(rndW, rndH);

            const resSize = rndW * rndH * 32;
            resBufA = device.createBuffer({ size: resSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
            resBufB = device.createBuffer({ size: resSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
            resBufInter = device.createBuffer({ size: resSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });

            // Temporal Pass A: Read Prev(A), Write Inter, Write G-Buff(A)
            // Bindings 1 (History) and 4 (ResOutput) are unused in Temporal Pass
            bindGroupATem = device.createBindGroup({ layout: computePipeTemporal.getBindGroupLayout(0), entries: [
                {binding:0, resource:{buffer:uBuff}}, 
                {binding:2, resource:texB.createView()}, // OutputTex (Used for dims)
                {binding:3, resource:{buffer:resBufA}}, // Input Reservoir (Prev)
                {binding:5, resource:texNormDepthA.createView()}, // NormDepthInput (Prev)
                {binding:6, resource:texNormDepthB.createView()}, // NormDepthOutput (Current)
                {binding:7, resource:{buffer:resBufInter}} // Inter
            ]});

            // Spatial Pass A: Read Inter, Write Next(B), Read G-Buff(A)
            // Bindings 3 (ResInput) and 6 (NormDepthOutput) are unused in Spatial Pass
            bindGroupASpa = device.createBindGroup({ layout: computePipeSpatial.getBindGroupLayout(0), entries: [
                {binding:0, resource:{buffer:uBuff}}, 
                {binding:1, resource:texA.createView()}, // History (Read)
                {binding:2, resource:texB.createView()}, // Output (Write)
                {binding:4, resource:{buffer:resBufB}}, // ResOutput (Write)
                {binding:5, resource:texNormDepthB.createView()}, // NormDepthInput (Current - Read)
                {binding:7, resource:{buffer:resBufInter}} // Inter (Read)
            ]});

            // Temporal Pass B: Read Prev(B), Write Inter, Write G-Buff(B)
            bindGroupBTem = device.createBindGroup({ layout: computePipeTemporal.getBindGroupLayout(0), entries: [
                {binding:0, resource:{buffer:uBuff}}, 
                {binding:2, resource:texA.createView()},
                {binding:3, resource:{buffer:resBufB}}, // Read Prev
                {binding:5, resource:texNormDepthB.createView()}, // Read Prev
                {binding:6, resource:texNormDepthA.createView()}, // Write Current
                {binding:7, resource:{buffer:resBufInter}}
            ]});

            // Spatial Pass B: Read Inter, Write Next(A), Read G-Buff(B)
            bindGroupBSpa = device.createBindGroup({ layout: computePipeSpatial.getBindGroupLayout(0), entries: [
                {binding:0, resource:{buffer:uBuff}}, 
                {binding:1, resource:texB.createView()}, 
                {binding:2, resource:texA.createView()}, 
                {binding:4, resource:{buffer:resBufA}}, // Write Next
                {binding:5, resource:texNormDepthA.createView()}, // Read Current
                {binding:7, resource:{buffer:resBufInter}}
            ]});
        
            // Denoise bind groups (ping-ponging for 5 levels)
            // We need pairs for each pass: (Input, Output)
            // Pass 1: In=RenderOutput, Out=TmpA
            // Pass 2: In=TmpA, Out=TmpB
            // Pass 3: In=TmpB, Out=TmpA ...
            
            // However, simpler: 
            // BindGroup 0: In=texB (Render Target), Out=texDenoiseA
            // BindGroup 1: In=texDenoiseA, Out=texDenoiseB
            // BindGroup 2: In=texDenoiseB, Out=texDenoiseA
            denoiseBindGroups = [];
            denoiseBindGroups.push(device.createBindGroup({ layout: denoisePipe.getBindGroupLayout(0), entries: [{binding:0, resource:texB.createView()}, {binding:1, resource:texDenoiseA.createView()}, {binding:2, resource:{buffer:denoiseBuff}}] }));
            denoiseBindGroups.push(device.createBindGroup({ layout: denoisePipe.getBindGroupLayout(0), entries: [{binding:0, resource:texA.createView()}, {binding:1, resource:texDenoiseA.createView()}, {binding:2, resource:{buffer:denoiseBuff}}] })); // Alternate render target source
            
            denoiseBindGroups.push(device.createBindGroup({ layout: denoisePipe.getBindGroupLayout(0), entries: [{binding:0, resource:texDenoiseA.createView()}, {binding:1, resource:texDenoiseB.createView()}, {binding:2, resource:{buffer:denoiseBuff}}] }));
            denoiseBindGroups.push(device.createBindGroup({ layout: denoisePipe.getBindGroupLayout(0), entries: [{binding:0, resource:texDenoiseB.createView()}, {binding:1, resource:texDenoiseA.createView()}, {binding:2, resource:{buffer:denoiseBuff}}] }));
        }

        function updateCam() {
            const s = 0.05;
            const fwd = [Math.sin(cam.yaw)*Math.cos(cam.pitch), Math.sin(cam.pitch), Math.cos(cam.yaw)*Math.cos(cam.pitch)];
            const r = [-fwd[2], 0, fwd[0]]; const rl = Math.hypot(r[0],r[2])||1; r[0]/=rl; r[2]/=rl;
            const u = [r[1]*fwd[2]-r[2]*fwd[1], r[2]*fwd[0]-r[0]*fwd[2], r[0]*fwd[1]-r[1]*fwd[0]];
            let moved = false;
            if(keys.w) { cam.pos[0]+=fwd[0]*s; cam.pos[1]+=fwd[1]*s; cam.pos[2]+=fwd[2]*s; moved=true; }
            if(keys.s) { cam.pos[0]-=fwd[0]*s; cam.pos[1]-=fwd[1]*s; cam.pos[2]-=fwd[2]*s; moved=true; }
            if(keys.d) { cam.pos[0]+=r[0]*s; cam.pos[1]+=r[1]*s; cam.pos[2]+=r[2]*s; moved=true; }
            if(keys.a) { cam.pos[0]-=r[0]*s; cam.pos[1]-=r[1]*s; cam.pos[2]-=r[2]*s; moved=true; }
            if(keys.e) { cam.pos[1]+=s; moved=true; } if(keys.q) { cam.pos[1]-=s; moved=true; }
            if(moved) frame = 0;
            return { fwd, r, u };
        }

        function loop(now) {
            const dt = now - lastTime; lastTime = now; fpsEl.innerText = Math.round(1000/dt);
            
            const vecs = updateCam();
            // If minSamplesMode is ON and we just reset (frame=0), we force 2 passes to get instant 2 samples.
            let passes = 1;
            if (minSamplesMode && frame === 0) {
                passes = 2;
            }

            // Update Matrices
            if (frame > 0) {
                prevViewProj.set(viewProj);
            }
            
            const aspect = canvas.width / canvas.height;
            const proj = Mat4.create();
            Mat4.perspective(proj, 1.5, aspect, 0.1, 100.0); // fovy=1.5 (~85 deg)
            const view = Mat4.create();
            const center = [
                cam.pos[0] + vecs.fwd[0],
                cam.pos[1] + vecs.fwd[1],
                cam.pos[2] + vecs.fwd[2]
            ];
            Mat4.lookAt(view, cam.pos, center, [0,1,0]); // Up vector is Y-up
            Mat4.multiply(viewProj, proj, view);
            
            if (frame === 0) {
                prevViewProj.set(viewProj);
            }

            let finalTex = null;

            for (let i = 0; i < passes; i++) {
                frame++;
                
                const uniformData = new Float32Array(36); 
                uniformData.set([...cam.pos, 0, ...vecs.fwd, 0, ...vecs.r, 0, ...vecs.u, 0], 0);
                uniformData.set(prevViewProj, 16);
                uniformData.set([texA.width, texA.height, frame, upscalingEnabled ? 1 : 0], 32);
                
                device.queue.writeBuffer(uBuff, 0, uniformData);

                const cBindTem = pingPong === 0 ? bindGroupATem : bindGroupBTem;
                const cBindSpa = pingPong === 0 ? bindGroupASpa : bindGroupBSpa;
                finalTex = pingPong === 0 ? texB : texA;
                
                const enc = device.createCommandEncoder();
                
                // Pass 1: Temporal (Candidates + Temporal Reuse + GBuffer Write)
                const cPass1 = enc.beginComputePass();
                cPass1.setPipeline(computePipeTemporal);
                cPass1.setBindGroup(0, cBindTem);
                cPass1.dispatchWorkgroups(Math.ceil(texA.width/16), Math.ceil(texA.height/16));
                cPass1.end();
                
                // Pass 2: Spatial (Spatial Reuse + Shade)
                const cPass2 = enc.beginComputePass();
                cPass2.setPipeline(computePipeSpatial);
                cPass2.setBindGroup(0, cBindSpa);
                cPass2.dispatchWorkgroups(Math.ceil(texA.width/16), Math.ceil(texA.height/16));
                cPass2.end();
                
                device.queue.submit([enc.finish()]);
                
                // Toggle for next pass
                pingPong = 1 - pingPong;
            }
            
            sampEl.innerText = frame;

            // Denoise & Render using finalTex (output of last pass)
            const enc = device.createCommandEncoder();

            if(denoisingEnabled) {
                const dPass = enc.beginComputePass();
                dPass.setPipeline(denoisePipe);
                
                let step = 1;
                
                // Denoise Input Bind Group:
                // We need to read 'finalTex'.
                // The bind groups are:
                // 0: Read B (write DenoiseA)
                // 1: Read A (write DenoiseA)
                const denoiseIdx = (finalTex === texB) ? 0 : 1;

                dPass.setBindGroup(0, denoiseBindGroups[denoiseIdx]); 
                device.queue.writeBuffer(denoiseBuff, 0, new Float32Array([texA.width, texA.height, step, 0]));
                dPass.dispatchWorkgroups(Math.ceil(texA.width/16), Math.ceil(texA.height/16));
                
                for(let i=0; i<2; i++) {
                    step *= 2;
                    let idx = 2 + (i%2); 
                    dPass.setBindGroup(0, denoiseBindGroups[idx]);
                    device.queue.writeBuffer(denoiseBuff, 0, new Float32Array([texA.width, texA.height, step, 0]));
                    dPass.dispatchWorkgroups(Math.ceil(texA.width/16), Math.ceil(texA.height/16));
                }
                dPass.end();
                
                finalTex = texDenoiseA; 
            }

            const rPass = enc.beginRenderPass({ colorAttachments: [{ view: context.getCurrentTexture().createView(), loadOp: 'clear', storeOp: 'store' }] });
            rPass.setPipeline(renderPipe);
            
            const dispBind = device.createBindGroup({ layout: renderPipe.getBindGroupLayout(0), entries: [{binding:0, resource:finalTex.createView()}, {binding:1, resource:sampler}, {binding:2, resource:{buffer:uBuff}}] });
            rPass.setBindGroup(0, dispBind);
            rPass.draw(6);
            rPass.end();

            device.queue.submit([enc.finish()]);
            
            requestAnimationFrame(loop);
        }

        function setupInput() {
            window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            
            // FSR Toggle
            const fsrBtn = document.getElementById('upscale-btn');
            const toggleFsr = (e) => {
                e.preventDefault();
                e.stopPropagation();
                upscalingEnabled = !upscalingEnabled;
                renderScale = upscalingEnabled ? 0.67 : 1.0;
                fsrBtn.style.background = upscalingEnabled ? 'rgba(100, 255, 100, 0.5)' : '';
                resize();
            };
            fsrBtn.addEventListener('pointerdown', toggleFsr);

            // Denoise Toggle
            const denoiseBtn = document.getElementById('denoise-btn');
            const toggleDenoise = (e) => {
                e.preventDefault();
                e.stopPropagation();
                denoisingEnabled = !denoisingEnabled;
                denoiseBtn.style.background = denoisingEnabled ? 'rgba(100, 255, 100, 0.5)' : '';
            };
            denoiseBtn.addEventListener('pointerdown', toggleDenoise);

            // Min Samples Toggle
            const minSamplesBtn = document.getElementById('min-samples-btn');
            const toggleMinSamples = (e) => {
                e.preventDefault();
                e.stopPropagation();
                minSamplesMode = !minSamplesMode;
                minSamplesBtn.style.background = minSamplesMode ? 'rgba(100, 255, 100, 0.5)' : '';
                frame = 0; // Reset frame counter when toggling
            };
            minSamplesBtn.addEventListener('pointerdown', toggleMinSamples);

            // Mouse
            canvas.addEventListener('click', () => canvas.requestPointerLock());
            window.addEventListener('mousemove', e => {
                if(document.pointerLockElement !== canvas) return;
                cam.yaw -= e.movementX*0.005; cam.pitch = Math.max(-1.5, Math.min(1.5, cam.pitch-e.movementY*0.005));
                frame = 0;
            });

            // Touch
            document.querySelectorAll('.btn:not(#upscale-btn):not(#denoise-btn):not(#min-samples-btn)').forEach(b => {
                b.addEventListener('touchstart', (e) => { e.preventDefault(); keys[b.dataset.key] = true; });
                b.addEventListener('touchend', (e) => { e.preventDefault(); keys[b.dataset.key] = false; });
            });
            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                if(dragTouchId !== null) return;
                const t = e.changedTouches[0];
                dragTouchId = t.identifier;
                lastMouse = {x:t.clientX, y:t.clientY};
            }, {passive: false});
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if(dragTouchId === null) return;
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(t.identifier === dragTouchId) {
                        const dx = t.clientX - lastMouse.x;
                        const dy = t.clientY - lastMouse.y;
                        lastMouse = {x:t.clientX, y:t.clientY};
                        // Inverted touch controls
                        cam.yaw += dx*0.005; cam.pitch = Math.max(-1.5, Math.min(1.5, cam.pitch+dy*0.005));
                        frame = 0;
                        break;
                    }
                }
            }, {passive: false});
            canvas.addEventListener('touchend', e => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === dragTouchId) { dragTouchId = null; }
                }
            });
        }
        init();
    </script>
</body>
</html>